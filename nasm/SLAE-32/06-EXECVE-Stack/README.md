# EXECVE-Stack

## SHELL (PREP)
In order to understand how `execve` works, look at the arguments it takes, and how this translates to the registers:  

```c
int execve(const char *pathname, char *const argv[], char *const envp[]);
```
**execve does NOT need a return if successful**

```nasm
EAX = syscall
EBX = /bin/bash, 0x0
ECX = Address of /bin/bash, 0x00000000
EDX = 0x00000000
ESI -> /bin/bash
```


## PYTHON (PREP)  

In order to get the `////bin/bash` string to print in hex and properly reversed to `PUSH` on the stack, use the following snippet:  
```python
python3 -c 'code=b"////bin/bash"; print(code[::-1].hex())'

687361622f6e69622f2f2f2f
```

Alternatively, use the following script:  
```python
#!/usr/bin/python3

import sys
input = sys.argv[1].encode()


print("String length: " + str(len(input)))

stringList = [input[i:i+4] for i in range(0, len(input), 4)]

for item in stringList[::-1]:
    print(item[::-1].decode() + " : " + item[::-1].hex())
```

Invoke it as follows:  
```python
python3 string_reverse.py '////bin/bash'
String length: 12
hsab : 68736162
/nib : 2f6e6962
//// : 2f2f2f2f
```

## NASM  

### EXECVE  
```nasm
; execve-Stack.nasm
; SLAE32
; EXECVE using Stack method, no NULL

global _start

section .text
_start: 

    xor eax, eax
    push eax            ; Push 0x00000000 (NULL DWORD)
    push 0x68736162     ; hsab          ////bin/bash - 12 chars, divisible by 4, and NULL terminated ^
    push 0x2f6e6962     ; /nib
    push 0x2f2f2f2f     ; ////

    mov ebx, esp        ; MOV address of ////bin/bash string just PUSH'd into EBX

    push eax            ; Push 0x00000000 (NULL DWORD) for EDX prep
    mov edx, esp        ; MOV this null address location in EDX register

    push ebx            ; Save address of WHERE the ////bin/bash,0x0 string is onto stack
    mov ecx, esp        ; MOV address of string into ECX

    mov al, 11
    int 0x80
```


---


## Convert to Shellcode  

Use the [compile.sh](../compile.sh) script that will automatically compile, assemble, link, and then print the shellcode for CPP consumption.  


---


## CPP  
### Header file (.h)  
```cpp
/*
Following video: Module 2-6: EXECVE Stack

    2-6_EXECVE-Stack/execve-stack:     file format elf32-i386
    
    
    Disassembly of section .text:
    
    08049000 <_start>:
     8049000:       31 c0                   xor    eax,eax
     8049002:       50                      push   eax
     8049003:       68 62 61 73 68          push   0x68736162
     8049008:       68 62 69 6e 2f          push   0x2f6e6962
     804900d:       68 2f 2f 2f 2f          push   0x2f2f2f2f
     8049012:       89 e3                   mov    ebx,esp
     8049014:       50                      push   eax
     8049015:       89 e2                   mov    edx,esp
     8049017:       53                      push   ebx
     8049018:       89 e1                   mov    ecx,esp
     804901a:       b0 0b                   mov    al,0xb
     804901c:       cd 80                   int    0x80
*/


unsigned char shellcode[] = {
"\x31\xc0\x50\x68\x62\x61\x73\x68\x68\x62\x69\x6e\x2f\x68\x2f\x2f"
"\x2f\x2f\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"
};

unsigned int shellcode_len = sizeof(shellcode)-1;
```

### CPP file (.cpp)  
```cpp
#include <stdio.h>
#include <string.h>
#include <stdint.h>		// Requirement for intptr_t/uintptr_t
// @ts-ignore
#include <sys/mman.h>	// Linux requirement for mmap / mprotect

// Clean place to keep all shellcode
#include "shellcode.h"

// Compile (x86) with:
// Note: Requires package gcc-multilib if on an x64 system
// gcc -g -m32 -z execstack -fno-stack-protector -o shellcode-2.2 linux-shellcode-func_ptr.cpp
//
// DISABLE ALL PROTECTIONS:
// gcc -m32 -w -o vuln_disable_canary -o vuln_disable_dep -o vuln_disable_pie -no-pie -z execstack -fno-stack-protector -Wl,-z,-norelro -Wa,--execstack -o shellcode shellcode-1.cpp
//
// Compile (x64) with:
// gcc -g -m64 -z execstack -fno-stack-protector -o <Outfile> <shellcode template>

int main()
{
	for (int i = 0; i < shellcode_len; i++){
		// printf("%02x ",*(shellcode + i));	// Output example: 31 c0 50 68
		printf("\\x%02x",*(shellcode + i));		// Output example: \x31\xc0\x50\x68
	}
	printf("\n");
	printf("Shellcode Length: %d\n", shellcode_len);

	// =====================================================
	// SLAE-32 method
	// Create a function pointer, that points to the raw shellcode, then call the shellcode pointer
	//
	int (*shellcode_func_ptr)() = (int(*)())shellcode;
	mprotect((void*)((uintptr_t)shellcode & ~0xFFF), 8192, PROT_READ|PROT_WRITE|PROT_EXEC);	// Required to add this to make the PAGE the shellcode is in, executable
	printf("Shellcode address: %p\n", shellcode_func_ptr);
	shellcode_func_ptr();
	// =====================================================


	// =====================================================
	// Memory Alloc method
	//
	// int prot = PROT_READ | PROT_WRITE | PROT_EXEC;
	// int flags = MAP_PRIVATE | MAP_ANONYMOUS;
	
	// void *shellcode_mem_alloc = mmap(0, shellcode_len, prot, flags, -1, 0);

	// if(shellcode_mem_alloc == MAP_FAILED)
	// {
	// 	perror("mmap");
	// 	return 1;	// Error'd out
	// }
	// else{
	// 	memcpy(shellcode_mem_alloc, shellcode, shellcode_len);
	// 	((void(*)())shellcode_mem_alloc)();
	// }
	// =====================================================


	return 0;
}
```


---

## Compilation (GCC)

### Compile (`x86`):
_Note: Requires package `gcc-multilib` if on an `x64` system_
```shell
gcc -g -m32 -z execstack -fno-stack-protector -o shellcode-2.2 linux-shellcode-func_ptr.cpp
```

### DISABLE ALL PROTECTIONS:
```shell
gcc -m32 -w -o vuln_disable_canary -o vuln_disable_dep -o vuln_disable_pie -no-pie -z execstack -fno-stack-protector -Wl,-z,-norelro -Wa,--execstack -o shellcode shellcode-1.cpp
```

### Compile (`x64`):
```shell
gcc -g -m64 -z execstack -fno-stack-protector -o <Outfile> <shellcode template>
```