# EXECVE-JMP_CALL_POP

## SHELL (PREP)
In order to understand how `execve` works, look at the arguments it takes, and how this translates to the registers:  

```c
int execve(const char *pathname, char *const argv[], char *const envp[]);
```
**execve does NOT need a return if successful**

```nasm
EAX = syscall
EBX = /bin/bash, 0x0
ECX = Address of /bin/bash, 0x00000000
EDX = 0x00000000
ESI -> /bin/bash
```

## NASM  

### Important!
```plain
[!] ===========================================================================
This will NOT work using NASM compiled code with default ld
The .text section has to be MADE writeable using ld -N
ld -N makes the .text and .data segments READABLE and WRITEABLE
[!] ===========================================================================
```
Line 21 in the `compile.sh` script has the `-N` option commented out.  Manually uncomment or run it manually to generate a writeable `.text` section:  
```shell
# -N to make .text & .data section WRITEABLE
ld -N -m elf_i386 -o $dirpath/$filename $dirpath/$filename.o
```

### EXECVE  
```nasm
; execve-JMP_CALL_POP.nasm
; SLAE32
; EXECVE using JMP CALL POP method, no NULL

global _start

section .text
_start: 
    jmp short call_shellcode

shellcode:
    pop esi                             ; Contains the address to /bin/bashABBBBCCCC string

    xor ebx, ebx
    mov byte [esi + 9], bl              ; MOV 0x0 into 9th character aka the A in the /bin/bashABBBBCCCC (Remember, everything starts at 0)

    mov dword [esi + 10], esi           ; Move the address from ESI register (which contains /bin/bash string) into the 10th character of the ESI string, where the Bs start in the /bin/bashABBBBCCCC
    mov dword [esi + 14], ebx           ; Convert CCCC to 0x00000000

    lea ebx, [esi]                      ; Move the prepped /bin/bash,0x0 into EBX
    
    lea ecx, [esi + 10]                 ; Address of /bin/bash,0x0, where the B's were previously

    lea edx, [esi + 14]                 ; 0x00000000, where the C's were previously

    xor eax, eax
    xor al, 0xb
    int 0x80

call_shellcode:
    call shellcode
    message db "/bin/bashABBBBCCCC"     ; A needs to become 0x0 AKA null-terminated
```


---


## Convert to Shellcode  

Use the [compile.sh](../compile.sh) script that will automatically compile, assemble, link, and then print the shellcode for CPP consumption.  
**Note**: `execve` here requires the `.text` section to be writeable, see Important above.  

---


## CPP  
### Header file (.h)  
```cpp
/*
Following video: Module 2-5: EXECVE JMP_CALL_POP

;   2-5_EXECVE-JMP_CALL_POP/execve-jmp_call_pop:     file format elf32-i386
;   
;   Disassembly of section .text:
;   
;   08049000 <_start>:
;    8049000:       eb 1a                   jmp    804901c <call_shellcode>
;   
;   08049002 <shellcode>:
;    8049002:       5e                      pop    esi
;    8049003:       31 db                   xor    ebx,ebx
;    8049005:       88 5e 09                mov    BYTE PTR [esi+0x9],bl
;    8049008:       89 76 0a                mov    DWORD PTR [esi+0xa],esi
;    804900b:       89 5e 0e                mov    DWORD PTR [esi+0xe],ebx
;    804900e:       8d 1e                   lea    ebx,[esi]
;    8049010:       8d 4e 0a                lea    ecx,[esi+0xa]
;    8049013:       8d 56 0e                lea    edx,[esi+0xe]
;    8049016:       31 c0                   xor    eax,eax
;    8049018:       34 0b                   xor    al,0xb
;    804901a:       cd 80                   int    0x80
;   
;   0804901c <call_shellcode>:
;    804901c:       e8 e1 ff ff ff          call   8049002 <shellcode>
;   
;   08049021 <message>:
;    8049021:       2f                      das
;    8049022:       62 69 6e                bound  ebp,QWORD PTR [ecx+0x6e]
;    8049025:       2f                      das
;    8049026:       62 61 73                bound  esp,QWORD PTR [ecx+0x73]
;    8049029:       68 41 42 42 42          push   0x42424241
;    804902e:       42                      inc    edx
;    804902f:       43                      inc    ebx
;    8049030:       43                      inc    ebx
;    8049031:       43                      inc    ebx
;    8049032:       43                      inc    ebx
*/


unsigned char shellcode[] = {
"\xeb\x1a\x5e\x31\xdb\x88\x5e\x09\x89\x76\x0a\x89\x5e\x0e"
"\x8d\x1e\x8d\x4e\x0a\x8d\x56\x0e\x31\xc0\x34\x0b\xcd\x80"
"\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x62\x61\x73\x68"
"\x41\x42\x42\x42\x42\x43\x43\x43\x43"
};

unsigned int shellcode_len = sizeof(shellcode)-1;
```

### CPP file (.cpp)  
```cpp
#include <stdio.h>
#include <string.h>
#include <stdint.h>		// Requirement for intptr_t/uintptr_t
// @ts-ignore
#include <sys/mman.h>	// Linux requirement for mmap / mprotect

// Clean place to keep all shellcode
#include "shellcode.h"

// Compile (x86) with:
// Note: Requires package gcc-multilib if on an x64 system
// gcc -g -m32 -z execstack -fno-stack-protector -o shellcode-2.2 linux-shellcode-func_ptr.cpp
//
// DISABLE ALL PROTECTIONS:
// gcc -m32 -w -o vuln_disable_canary -o vuln_disable_dep -o vuln_disable_pie -no-pie -z execstack -fno-stack-protector -Wl,-z,-norelro -Wa,--execstack -o shellcode shellcode-1.cpp
//
// Compile (x64) with:
// gcc -g -m64 -z execstack -fno-stack-protector -o <Outfile> <shellcode template>

int main()
{
	for (int i = 0; i < shellcode_len; i++){
		// printf("%02x ",*(shellcode + i));	// Output example: 31 c0 50 68
		printf("\\x%02x",*(shellcode + i));		// Output example: \x31\xc0\x50\x68
	}
	printf("\n");
	printf("Shellcode Length: %d\n", shellcode_len);

	// =====================================================
	// SLAE-32 method
	// Create a function pointer, that points to the raw shellcode, then call the shellcode pointer
	//
	int (*shellcode_func_ptr)() = (int(*)())shellcode;
	mprotect((void*)((uintptr_t)shellcode & ~0xFFF), 8192, PROT_READ|PROT_WRITE|PROT_EXEC);	// Required to add this to make the PAGE the shellcode is in, executable
	printf("Shellcode address: %p\n", shellcode_func_ptr);
	shellcode_func_ptr();
	// =====================================================


	// =====================================================
	// Memory Alloc method
	//
	// int prot = PROT_READ | PROT_WRITE | PROT_EXEC;
	// int flags = MAP_PRIVATE | MAP_ANONYMOUS;
	
	// void *shellcode_mem_alloc = mmap(0, shellcode_len, prot, flags, -1, 0);

	// if(shellcode_mem_alloc == MAP_FAILED)
	// {
	// 	perror("mmap");
	// 	return 1;	// Error'd out
	// }
	// else{
	// 	memcpy(shellcode_mem_alloc, shellcode, shellcode_len);
	// 	((void(*)())shellcode_mem_alloc)();
	// }
	// =====================================================


	return 0;
}
```


---

## Compilation (GCC)

### Compile (`x86`):
_Note: Requires package `gcc-multilib` if on an `x64` system_
```shell
gcc -g -m32 -z execstack -fno-stack-protector -o shellcode-2.2 linux-shellcode-func_ptr.cpp
```

### DISABLE ALL PROTECTIONS:
```shell
gcc -m32 -w -o vuln_disable_canary -o vuln_disable_dep -o vuln_disable_pie -no-pie -z execstack -fno-stack-protector -Wl,-z,-norelro -Wa,--execstack -o shellcode shellcode-1.cpp
```

### Compile (`x64`):
```shell
gcc -g -m64 -z execstack -fno-stack-protector -o <Outfile> <shellcode template>
```